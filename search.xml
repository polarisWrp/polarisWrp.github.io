<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写常见js函数or方法</title>
      <link href="/2022/061421649.html"/>
      <url>/2022/061421649.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见功能函数"><a href="#一、常见功能函数" class="headerlink" title="一、常见功能函数"></a>一、常见功能函数</h2><h3 id="1-防抖，节流函数"><a href="#1-防抖，节流函数" class="headerlink" title="1. 防抖，节流函数"></a>1. 防抖，节流函数</h3><h4 id="1-1-函数防抖"><a href="#1-1-函数防抖" class="headerlink" title="1.1 函数防抖"></a>1.1 函数防抖</h4><ul><li>在延时时间内多次点击，每次点击都会重置延时时间；类似于坐电梯，在一定时间内只要有人按开关，那么电梯就不会关上。</li></ul><pre><code class="js">//执行函数， 延迟时长， 是否立即执行debounceFn(fn, delay, immediate)&#123;    let timer = null    return function () &#123;        const arg = arguments        cons that = this        if (immediate) &#123;          fn.apply(that,arg)          immediate = false          return        &#125;        if (timer) clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            fn.apply(that, arg)        &#125;, 1000)    &#125;&#125;</code></pre><h4 id="1-2-函数节流"><a href="#1-2-函数节流" class="headerlink" title="1.2 函数节流"></a>1.2 函数节流</h4><ul><li>一定时间内多次点击，执行固定次数</li></ul><pre><code class="js">function throttle(fn, wait, immediate) &#123;  let timer = null   return function () &#123;    let _this = this    let args = arguments    if (immediate) &#123;        fn.apply(_this, args)        immediate = false        return    &#125;    if (!timer) &#123;       timeout = setTimeout(() =&gt; &#123;        timer = null;        fn.apply(_this, args)      &#125;, wait)    &#125;  &#125;&#125;</code></pre><h3 id="2-递归函数"><a href="#2-递归函数" class="headerlink" title="2. 递归函数"></a>2. 递归函数</h3><h4 id="2-1-递归取出数组中指定的属性值"><a href="#2-1-递归取出数组中指定的属性值" class="headerlink" title="2.1 递归取出数组中指定的属性值"></a>2.1 递归取出数组中指定的属性值</h4><ul><li>数据结构类似如下，嵌套的数据模型与外层相同</li></ul><pre><code class="typescript">interface Type &#123;    name: string    children: Array&lt;Type&gt; | undefined&#125; list: Array&lt;Type&gt; = [      &#123;        name: &#39;kkk&#39;,        children: [          &#123;            name: &#39;ppp&#39;,            children: [              &#123;                name: &#39;uuu&#39;,                children: [],              &#125;            ]          &#125;,        ]      &#125; ]</code></pre><ul><li>需求：将数组中name属性值取出，拼接成字符串</li><li>关键点在于 temp 这个数据需要与递归函数隔离开，否则每次调用函数都会重置temp函数；从而无法获取所有名称集合</li></ul><pre><code class="typescript">getTypeName(arr: Array&lt;Type&gt;): string &#123;    if (!arr?.length) return &#39;-&#39;    let temp = new Array&lt;string&gt;()    function recursiveFn(list: Array&lt;Type&gt;) &#123;        list?.forEach((item) =&gt; &#123;            if (item?.children?.length) &#123;                temp.push(item.name)                recursiveFn(item?.children)            &#125; else &#123;                temp.push(item.name)            &#125;        &#125;)    &#125;    recursiveFn(arr)    return temp?.join(&#39;&gt;&#39;) || &#39;-&#39;&#125;</code></pre><h4 id="2-2-将嵌套的数组数据转为json树形结构"><a href="#2-2-将嵌套的数组数据转为json树形结构" class="headerlink" title="2.2 将嵌套的数组数据转为json树形结构"></a>2.2 将嵌套的数组数据转为json树形结构</h4><ul><li>数据源如下</li></ul><pre><code class="js">const arr = [1, 2, [3, [4, 5], 6], 7, [8], 9]方法一function recursiveFn(list) &#123;    const result = []    for (let i = 0; i &lt; list?.length; i++) &#123;        if (typeof list[i] === &#39;number&#39;) &#123;            result.push(&#123;                value: list[i]            &#125;)        &#125; else if (Array.isArray(list[i]))&#123;            result.push(&#123;                children: recursiveFn(list[i])            &#125;)        &#125;    &#125;    return result&#125;方法二function recursiveFn2(arr) &#123;    if (typeof arr === &#39;number&#39;) &#123;        return &#123;            value: arr        &#125;    &#125; else if (Array.isArray(arr)) &#123;        return arr?.map(item =&gt; recursiveFn2(item))    &#125;&#125;recursiveFn(arr)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日计划-Day Day Up</title>
      <link href="/2022/061312805.html"/>
      <url>/2022/061312805.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、手写js题目"><a href="#一、手写js题目" class="headerlink" title="一、手写js题目"></a>一、手写js题目</h1><ul><li>防抖节流，promise函数，对象的深浅拷贝，js原型、原型链，instanceof</li><li>js事件循环机制（nextTick原理），浏览器回流与重绘，js闭包，js精度丢失</li><li>常用排序算法 插入，冒泡，快速，选择 <h1 id="二、Vue2核心api的手写"><a href="#二、Vue2核心api的手写" class="headerlink" title="二、Vue2核心api的手写"></a>二、Vue2核心api的手写</h1></li><li>双向绑定（响应式原理）</li><li>nextTick原理</li><li>diff算法</li><li>AST抽象语法树<h1 id="三、了解Vue3"><a href="#三、了解Vue3" class="headerlink" title="三、了解Vue3"></a>三、了解Vue3</h1></li><li>搭建项目，熟悉api使用</li><li>区分V3提升点</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> My Schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用webpack搭建vuecli</title>
      <link href="/2022/061258326.html"/>
      <url>/2022/061258326.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础步骤"><a href="#一、基础步骤" class="headerlink" title="一、基础步骤"></a>一、基础步骤</h1><ol><li><code>npm init</code> 初始化 <code>package.json</code>文件</li><li>创建src目录-&gt;在此目录下创建 main.js 文件作为入口文件</li><li>在 <code>package.json</code> 文件内新增打包命令</li><li>执行 <code>npm run build</code> 查看是否打包成功 （成功的话dist文件夹下会新增打包的文件）<h1 id="二、webpack基础配置"><a href="#二、webpack基础配置" class="headerlink" title="二、webpack基础配置"></a>二、webpack基础配置</h1><h2 id="1、新建文件"><a href="#1、新建文件" class="headerlink" title="1、新建文件"></a>1、新建文件</h2><ul><li>在项目根目录下新增build目录，并且创建<code>webpack.config.js</code>文件<h2 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h2></li></ul></li></ol><ul><li>webpack.config.js 写入</li></ul><pre><code class="js">// 引入核心模块path，用户获取文件路径const path = require(&#39;path&#39;)// 导出配置信息module.exports = &#123;    // 设置模式    development， production 开发、生产模式    默认生产模式，也可以设置为 none */    mode: &#39;development&#39;,    // 设置入口文件路径    entry: path.resolve(__dirname, &#39;../src/main.js&#39;),        // 设置输出信息        output: &#123;            // 输出文件名            filename: &#39;budle.js&#39;,                path: path.resolve(__dirname, &#39;../build&#39;)        &#125;&#125;</code></pre><h2 id="3、更改打包"><a href="#3、更改打包" class="headerlink" title="3、更改打包"></a>3、更改打包</h2><ul><li>在<code>package.json</code>文件中更改打包命令，并且执行<code>npm run build</code><pre><code>&quot;build&quot;: &quot;webpack --config build/webpack.config.js&quot;</code></pre></li></ul><p><img src="https://cdn.jsdelivr.net/gh/polarisWrp/photo_stage/images/pic202206120412542.png" alt="image-20220612041213620"></p><h2 id="4、缓存以及自动引入js"><a href="#4、缓存以及自动引入js" class="headerlink" title="4、缓存以及自动引入js"></a>4、缓存以及自动引入js</h2><ul><li>HTML自动引入打包后的js文件</li></ul><ol><li>使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 &#x2F;dist 目录，然后把打包后的内容放置在此目录中。</li><li>只要 <strong>dist</strong> 目录中的内容部署到 <strong>server</strong> 上，client（通常是浏览器）就能够访问此 server 的网站及其资源。而最后一步获取资源是比较耗费时间的，所以浏览器会使用 <strong>缓存</strong> 。</li><li>浏览器通过<strong>命中缓存</strong>，以降低网络流量，使网站加载速度更快；但是如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。</li></ol><ul><li>基于以上我们不能每次打包生成同样的文件名，也不会每次打包后去更改 <code>index.html</code> 文件里面引入的打包后的js文件 </li><li>每次打包生成不同名称的文件 <code> html-webpack-plugin</code></li></ul><pre><code class="js">// 安装npm i -D html-webpack-plugin@4</code></pre><h3 id="4-1、新增-public-文件夹，创建-index-html-作为我们的模板文件"><a href="#4-1、新增-public-文件夹，创建-index-html-作为我们的模板文件" class="headerlink" title="4.1、新增 public 文件夹，创建 index.html 作为我们的模板文件"></a>4.1、新增 public 文件夹，创建 index.html 作为我们的模板文件</h3><ul><li>在<code>webpack.config.js</code>中新增配置</li><li>修改输出文件名，确保每次生成的js文件名称不重复</li><li>新增<code>plugin</code>配置，查看生成的<code>index.html</code>文件中是否自动引入了js文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/polarisWrp/photo_stage/images/pic202206120422014.png" alt="image-20220612042202935"></p><h2 id="5、多入口文件的开发"><a href="#5、多入口文件的开发" class="headerlink" title="5、多入口文件的开发"></a>5、多入口文件的开发</h2><ul><li>定义：多入口文件就是<strong>设置</strong>多个入口文件和<strong>输出</strong>对应打包后的文件</li></ul><ol><li><p>配置单个入口文件时： entry为一个属性</p></li><li><p>配置多个入口文件： entry需要配置成一个对象</p><p>2.1 对象里面的 <strong>属性名</strong> 就是该入口文件的标识，<strong>属性值</strong>就是对应的文件路径，输出时需要在对应的<code>html</code>文件中引入，我们可以通过配置多个<code>html-webpack-plugin</code>的方式实现。</p><p>2.2 在<code>html-webpack-plugin</code>中需要 设置<code>filename</code>来设置输出的<code>html</code>文件名，<code>chunks</code>来关联上面<code>entry</code>里面的入口文件</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/polarisWrp/photo_stage/images/pic202206120426600.png" alt="image-20220612042639527"></p><h3 id="5-1、配置栗子"><a href="#5-1、配置栗子" class="headerlink" title="5.1、配置栗子"></a>5.1、配置栗子</h3><p><del>Talk is cheap,show the code</del></p><pre><code class="js">// 引入核心模块path，用户获取文件路径const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const path = require(&#39;path&#39;)// 导出配置信息module.exports = &#123;  /* 设置模式  development， production 开发、生产模式  默认生产模式，也可以设置为 none */  mode: &#39;development&#39;,  // 设置入口文件路径  entry: &#123;    main: path.resolve(__dirname, &#39;../src/main.js&#39;),    other: path.resolve(__dirname, &#39;../src/other.js&#39;)  &#125;,  // 设置输出信息  output: &#123;    // 输出文件名    filename: &#39;[name].[hash:8].js&#39;,    path: path.resolve(__dirname, &#39;../build&#39;)  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      // 设置模板      template: path.resolve(__dirname, &#39;../public/index.html&#39;),      filename: &#39;index.html&#39;,      chunks: [&#39;main&#39;]    &#125;),    new HtmlWebpackPlugin(&#123;      template: path.resolve(__dirname, &#39;../public/other.html&#39;),      filename: &#39;other.html&#39;,      chunks: [&#39;other&#39;] //关联上面entry的类名    &#125;)  ]&#125;</code></pre><h3 id="5-2、清除残余文件，插件-clean-webpack-plugin"><a href="#5-2、清除残余文件，插件-clean-webpack-plugin" class="headerlink" title="5.2、清除残余文件，插件 clean-webpack-plugin"></a>5.2、清除残余文件，插件 <code>clean-webpack-plugin</code></h3><ul><li>由于每次打包都会生成新的文件，旧的文件依旧残留在dist目录里；我们需要的是新的生成之后删除旧的文件</li></ul><pre><code class="js">npm i -D clean-webpack-plugin//引入const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;)// 注册plugins: [ new CleanWebpackPlugin()  ]</code></pre><h1 id="三、处理除了js以外的文件"><a href="#三、处理除了js以外的文件" class="headerlink" title="三、处理除了js以外的文件"></a>三、处理除了js以外的文件</h1><ul><li><code>webpack</code>默认只能处理 <strong>js</strong> 和 <strong>json</strong> 文件，要想对其他文件生效，需要加载对应的<code>loader</code></li></ul><h3 id="1、引用css文件"><a href="#1、引用css文件" class="headerlink" title="1、引用css文件"></a>1、引用css文件</h3><ol><li>新建<code>assets</code>静态文件夹，新增<code>normal.css</code>文件</li><li>使用预处理器如 <code>less  sass </code>等，需要安装对应加载器以及新增 <code>.less</code>或 <code>.scss</code>文件</li></ol><pre><code class="js">//**注意版本号是否兼容**npm i -D style-loader@2 css-loader@3  //如果使用预处理器，则需要多安装相应的预处理器和loadernpm i -D less less-loader@5</code></pre><ul><li>在<code>webpack.config.js</code>文件中新增 <code>loader</code>配置</li></ul><pre><code class="js"> module.exports = &#123;    module: &#123;        rules: [          &#123;            // 正则匹配所有 .css 结尾的文件            test: /\.css$/,            // 匹配到之后使用的loader，从右向左解析            use: [&#39;style-loader&#39;, &#39;css-loader&#39;]          &#125;,          &#123;            test: /\.less$/,            use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]          &#125;        ]  &#125;&#125;</code></pre><h3 id="2、添加浏览器前缀"><a href="#2、添加浏览器前缀" class="headerlink" title="2、添加浏览器前缀"></a>2、添加浏览器前缀</h3><ul><li><code>**postcss-loader autoprefixer**</code></li></ul><pre><code class="js">//注意版本号npm i -D postcss-loader@4 autoprefixer@81.在module中配置postcss-loader    module: &#123;        rules: [             &#123;              //正则匹配所有.css结尾的文件              test:/\.css$/,              //匹配到之后使用的loader,从右向左解析              use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;postcss-loader&#39;]          &#125;,          &#123;              test:/\.less$/,              use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;postcss-loader&#39;,&#39;less-loader&#39;]          &#125;        ]     &#125;2. 使autoperfixer生效的方式  2.1方式一：在1.基础上还需要在项目根目录新增postcss.config.js配置文件；添加如下配置    module.exports = &#123;      plugins:[require(&#39;autoprefixer&#39;)]    &#125;  2.2方式二：在1. 的基础上修改配置如下     use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#123;         loader: &#39;postcss-loader&#39;,         options: &#123;             plugins:[require(&#39;autoprefixer&#39;)]         &#125;     &#125;,&#39;less-loader&#39;]</code></pre><ul><li>在<code>index.html</code>中样式被添加到了style标签中；但如果样式文件过多的时候；index文件就会过于混乱，咱们需要把css文件拆分出去。通过外链的方式引入。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/polarisWrp/photo_stage/images/pic202206120444950.png" alt="image-20220612044417880"></p><h3 id="3、抽离css文件-mini-css-extract-plugin-，以外链的方式引入它"><a href="#3、抽离css文件-mini-css-extract-plugin-，以外链的方式引入它" class="headerlink" title="3、抽离css文件  **mini-css-extract-plugin** ，以外链的方式引入它"></a>3、抽离css文件  <code>**mini-css-extract-plugin** </code>，以外链的方式引入它</h3><pre><code class="js">npm i -D mini-css-extract-plugin@0.9.0module:&#123;        //配置模块规则        rules:[            &#123;                //正则匹配所有.css结尾的文件                test:/\.css$/i,                //匹配到之后使用的loader,从右向左解析                use:[MiniCssExtractPlugin.loader,&#39;css-loader&#39;,&#39;postcss-loader&#39;]            &#125;,            &#123;                test:/\.less$/i,                use:[MiniCssExtractPlugin.loader,&#39;css-loader&#39;,&#39;postcss-loader&#39;,&#39;less-loader&#39;]            &#125;                    ] &#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/polarisWrp/photo_stage/images/pic202206120445073.png" alt="image-20220612044525018"></p><h3 id="4、打包其他文件：图片，字体，媒体等"><a href="#4、打包其他文件：图片，字体，媒体等" class="headerlink" title="4、打包其他文件：图片，字体，媒体等"></a>4、打包其他文件：图片，字体，媒体等</h3><pre><code class="js">1. 对图片、字体、媒体等静态资源一般使用url-loader进行处理后放入打包目录里面，2. url-loader:如果文件小于限制的大小会转成base64编码,否则使用file-loader将文件移动到输出的目录中3. url-loader内置了file-loader所以不需要安装file-loadernpm i -D  url-loader@4 file-loader@4rules:[       //处理图片    &#123;        //正则匹配图片格式        test:/\.(jpe?g|png|gif)$/i,        use:[            &#123;                loader:&#39;url-loader&#39;,                options:&#123;                    //限制文件大小                    limit:10240,                    //超出上面限制之后使用的loader ext是文件本来的扩展名                    name:&#39;image/[name].[hash:8].[ext]&#39;                &#125;            &#125;        ]    &#125;,]执行npm run build 可以看到dist文件下下面多了image文件夹，里面包含刚才在main.js里引入的图片，其他静态资源配置类似。</code></pre><h3 id="5、babel-loader需要和babel-core搭配使用"><a href="#5、babel-loader需要和babel-core搭配使用" class="headerlink" title="5、babel-loader需要和babel-core搭配使用"></a>5、babel-loader需要和babel-core搭配使用</h3><ul><li>因为不是所有浏览器都能支持es6+语法，需要我们转义成es5</li></ul><pre><code class="js">babel-loader 8.x 对应babel-core 7.xbabel-loader 7.x 对应babel-core 6.xnpm i -D babel-loader @babel/preset-env @babel/corerules:[       //处理js语法浏览器兼容问题    &#123;        test:&#39;/\.js$/&#39;,        use:&#123;            loader:&#39;bable-loader&#39;,            options:&#123;                presets:[&#39;@babel/preset-env&#39;]            &#125;        &#125;,        //排除依赖下的js        exclude:/node_modules/    &#125;]</code></pre><ul><li>使用<code>babel-loader</code>不能处理如promise,generator,set,map,proxy等新的api，需要借助<code>babel-polyfill</code></li></ul><pre><code class="js">npm i -D bable/polyfill// 更改入口文件配置entry:&#123;    main:[&quot;@babel/polyfill&quot;,path.resolve(__dirname,&#39;../src/main.js&#39;)],    other:[&quot;@babel/polyfill&quot;,path.resolve(__dirname,&#39;../src/other.js&#39;)]&#125;</code></pre><ul><li>至此，都是基础webpack4版本对js,css等静态资源的基础配置</li></ul><pre><code class="js">// 引入内置模块path, 用于获取文件路径const path = require(&#39;path&#39;)/* 插件plugin */const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)const &#123; CleanWebpackPlugin &#125; = require(&#39;clean-webpack-plugin&#39;)const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)const &#123; loader &#125; = require(&#39;mini-css-extract-plugin&#39;)// 导出配置信息module.exports = &#123;  /*     设置模式，默认为生产模式 production;也可以是none  */  mode: &#39;development&#39;,  /*     入口文件 【单个入口是属性，配置多个入口是需要配置成对象】    path.reslove() 由相对路劲计算出绝对路径; __dirname指的是当前模块的目录名称  */  // entry: path.resolve(__dirname, &#39;../src/main.js&#39;),  entry: &#123;    main: [&quot;@babel/polyfill&quot;, path.resolve(      __dirname,      &#39;../src/main.js&#39;    )],    other:[&quot;@babel/polyfill&quot;, path.resolve(      __dirname,      &#39;../src/other.js&#39;    )],  &#125;,  /* 出口信息 */  output: &#123;    // 输出文件名 确保每次生成的文件名不重复，防止文件更新后浏览器仍使用缓存文件    filename: &#39;[name].[hash:8].js&#39;,    // 输出文件路径    path: path.resolve(      __dirname,      &#39;../dist&#39;    ),  &#125;,  plugins: [    // 该插件会自动引入生成的js文件    new HtmlWebpackPlugin(&#123;      template: path.resolve(        __dirname,        &#39;../public/index.html&#39;      ), // 设置html模板      filename: &#39;index.html&#39;,      chunks: [&#39;main&#39;], //用于关联entry的文件    &#125;),    new HtmlWebpackPlugin(&#123;      template: path.resolve(        __dirname,        &#39;../public/other.html&#39;      ),      filename: &#39;other.html&#39;,      chunks: [&#39;other&#39;],    &#125;),    new CleanWebpackPlugin(),    new MiniCssExtractPlugin(&#123;      filename: &#39;[name].[hash:8].css&#39;,      chunkFilename: &#39;[id].css&#39;,    &#125;),  ],  module: &#123;    // 配置模块规则    rules: [      &#123;        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,          &#39;postcss-loader&#39;,        ],      &#125;,      &#123;        test: /\.less$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,          &#39;postcss-loader&#39;,          &#39;less-loader&#39;,        ],      &#125;,      &#123;        test: /\.(jp?g|png|gif)$/i,        use: [          &#123;            loader: &#39;url-loader&#39;,            options: &#123;              limit: 10240,              fallback: &#123;                loader: &#39;file-loader&#39;,                options: &#123;                  // 超出限制之后使用file-loader;ext是文件本来的扩展名                  name: &#39;image/[name].[hash:8].[ext]&#39;,                &#125;,              &#125;,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, //媒体文件        use: [          &#123;            loader: &#39;url-loader&#39;,            options: &#123;              limit: 10240,              fallback: &#123;                loader: &#39;file-loader&#39;,                options: &#123;                  name: &#39;media/[name].[hash:8].[ext]&#39;,                &#125;,              &#125;,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/i, // 字体        use: [          &#123;            loader: &#39;url-loader&#39;,            options: &#123;              limit: 10240,              fallback: &#123;                loader: &#39;file-loader&#39;,                options: &#123;                  name: &#39;fonts/[name].[hash:8].[ext]&#39;,                &#125;,              &#125;,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: /\.js$/,        use: [          &#123;            loader: &#39;babel-loader&#39;,            options: &#123;              presets: [                &#39;@babel/preset-env&#39;,              ],            &#125;,          &#125;,        ],        // 排除依赖下的js        exclude: /node_modules/,      &#125;,    ],  &#125;,&#125;</code></pre><h1 id="四、搭建一个vue-cli"><a href="#四、搭建一个vue-cli" class="headerlink" title="四、搭建一个vue-cli"></a>四、搭建一个vue-cli</h1><h2 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h2><ol><li>vue是单文件组件，使用的是.vue文件，需要使用vue-loader来解析.vue文件</li><li>每个vue文件里面包含三个部分template(模板)、script(逻辑)、style(样式)；需要使用vue-template-compiler来编译模板,vue-style-loader来应用样式</li></ol><h2 id="2、依赖安装"><a href="#2、依赖安装" class="headerlink" title="2、依赖安装"></a>2、依赖安装</h2><ul><li><code>npm i -D vue-loader vue-template-compiler vue-style-loader </code></li><li><code>npm i -S vue</code></li></ul><h3 id="2-1、配置-webpack-dev-server-进行热更新"><a href="#2-1、配置-webpack-dev-server-进行热更新" class="headerlink" title="2.1、配置 webpack-dev-server 进行热更新"></a>2.1、配置 <code>webpack-dev-server</code> 进行热更新</h3><ul><li>热更新允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面。热更新中的<strong>热</strong>我们可以理解为这个模块正在运行中，<strong>热替换</strong>就是将<strong>正在运行的模块</strong>进行替换。</li></ul><pre><code class="js">npm i -D webpack-dev-serverwebpack.config.js新增配置1. 配置开发服务器  devServer: &#123;    port: 8080,    hot: true, //开启热更新    contentBase: &#39;../dist&#39; //告诉服务器内容来源  &#125;,2. src目录下新增App.vue作为根组件3. 修改public文件下的index.html;它添加 div4. package.json 新增配置 &quot;dev&quot;: &quot;webpack-dev-server --config build/webpack.config.js --open&quot;5. 更改webpack-cli版本号 npm i -D webpack-cli@3</code></pre><pre><code class="js">package.json&#123;  &quot;name&quot;: &quot;webpack_4&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server --config build/webpack.config.js --open&quot;,    &quot;build&quot;: &quot;webpack --config build/webpack.config.js&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.18.2&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.18.2&quot;,    &quot;@webpack-cli/serve&quot;: &quot;^1.6.1&quot;,    &quot;autoprefixer&quot;: &quot;^8.6.5&quot;,    &quot;babel-loader&quot;: &quot;^8.2.5&quot;,    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;css-loader&quot;: &quot;^3.6.0&quot;,    &quot;file-loader&quot;: &quot;^4.3.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^4.5.2&quot;,    &quot;less&quot;: &quot;^4.1.2&quot;,    &quot;less-loader&quot;: &quot;^5.0.0&quot;,    &quot;mini-css-extract-plugin&quot;: &quot;^0.9.0&quot;,    &quot;postcss-loader&quot;: &quot;^4.3.0&quot;,    &quot;style-loader&quot;: &quot;^2.0.0&quot;,    &quot;url-loader&quot;: &quot;^4.1.1&quot;,    &quot;vue&quot;: &quot;^2.6.14&quot;,    &quot;vue-loader&quot;: &quot;^15.7.0&quot;,    &quot;vue-style-loader&quot;: &quot;^4.1.3&quot;,    &quot;vue-template-compiler&quot;: &quot;^2.6.14&quot;,    &quot;webpack&quot;: &quot;^4.46.0&quot;,    &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@babel/polyfill&quot;: &quot;^7.12.1&quot;,    &quot;@vue/compiler-sfc&quot;: &quot;^3.2.36&quot;  &#125;&#125;</code></pre><pre><code class="js">webpack.config.js// 引入内置模块path, 用于获取文件路径const path = require(&#39;path&#39;)/* 插件plugin */const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)const &#123; CleanWebpackPlugin &#125; = require(&#39;clean-webpack-plugin&#39;)const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)const webpack = require(&#39;webpack&#39;)// 导出配置信息module.exports = &#123;  // 配置开发服务器  devServer: &#123;    static: &#123;      directory: path.join(__dirname, &#39;dist&#39;)//告诉服务器内容来源    &#125;,    port: 8080,    hot: true, //开启热更新  &#125;,  /* 设置模式，默认为生产模式 production;也可以是none*/  mode: &#39;development&#39;,  /*     入口文件 【单个入口是属性，配置多个入口是需要配置成对象】    path.reslove() 由相对路劲计算出绝对路径; __dirname指的是当前模块的目录名称  */  entry: &#123;    main: path.resolve(__dirname, &#39;../src/main.js&#39;)  &#125;,   /* 出口信息 */  output: &#123;    // 输出文件名 确保每次生成的文件名不重复，防止文件更新后浏览器仍使用缓存文件    filename: &#39;[name].[hash:8].js&#39;,    // 输出文件路径    path: path.resolve(__dirname, &#39;../dist&#39;),  &#125;,  plugins: [    // 该插件会自动引入生成的js文件    new HtmlWebpackPlugin(&#123;      template: path.resolve(        __dirname,        &#39;../public/index.html&#39;      ), // 设置html模板      filename: &#39;index.html&#39;,      chunks: [&#39;main&#39;], //用于关联entry的文件    &#125;),    new CleanWebpackPlugin(),    new MiniCssExtractPlugin(&#123;      filename: &#39;[name].[hash:8].css&#39;,      chunkFilename: &#39;[id].css&#39;,    &#125;),    new VueLoaderPlugin(),    new webpack.HotModuleReplacementPlugin(),     ],  module: &#123;    // 配置模块规则    rules: [      &#123;        test: /\.vue$/,        use: [&#39;vue-loader&#39;]      &#125;,      &#123;        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,          &#39;postcss-loader&#39;,        ],      &#125;,      &#123;        test: /\.less$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,          &#39;postcss-loader&#39;,          &#39;less-loader&#39;,        ],      &#125;,      &#123;        test: /\.(jp?g|png|gif)$/i,        use: [          &#123;            loader: &#39;url-loader&#39;,            options: &#123;              limit: 10240,              fallback: &#123;                loader: &#39;file-loader&#39;,                options: &#123;                  // 超出限制之后使用file-loader;ext是文件本来的扩展名                  name: &#39;image/[name].[hash:8].[ext]&#39;,                &#125;,              &#125;,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, //媒体文件        use: [          &#123;            loader: &#39;url-loader&#39;,            options: &#123;              limit: 10240,              fallback: &#123;                loader: &#39;file-loader&#39;,                options: &#123;                  name: &#39;media/[name].[hash:8].[ext]&#39;,                &#125;,              &#125;,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/i, // 字体        use: [          &#123;            loader: &#39;url-loader&#39;,            options: &#123;              limit: 10240,              fallback: &#123;                loader: &#39;file-loader&#39;,                options: &#123;                  name: &#39;fonts/[name].[hash:8].[ext]&#39;,                &#125;,              &#125;,            &#125;,          &#125;,        ],      &#125;,      &#123;        test: /\.js$/,        use: [          &#123;            loader: &#39;babel-loader&#39;,            options: &#123;              presets: [                &#39;@babel/preset-env&#39;,              ],            &#125;,          &#125;,        ],        // 排除依赖下的js        exclude: /node_modules/,      &#125;,    ],  &#125;,  // 配置模块的解析规则  resolve: &#123;    // 创建别名    alias: &#123;      &#39;vue$&#39;: &#39;vue/dist/vue.runtime.esm.js&#39;,      // 设置@引用的地址为根目录下的src      &#39;@&#39;: path.resolve(__dirname, &#39;../src&#39;)    &#125;,    //按顺序解析以下数组后缀名的文件    extensions: [&#39;*&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.vue&#39;]  &#125;&#125;</code></pre><h2 id="3、区分开发环境与生产环境"><a href="#3、区分开发环境与生产环境" class="headerlink" title="3、区分开发环境与生产环境"></a>3、区分开发环境与生产环境</h2><ul><li>在build目录下新增两个文件,webpack.dev.js     webpack.prod.js</li><li><strong>开发环境</strong>主要是要实现热更新,不需要压缩代码，完整的sourceMap</li><li><strong>生产环境</strong>需要压缩代码、提取css文件、合理的sourceMap、分割代码等</li></ul><pre><code class="js">1. 使用webpack-marge 合并配置采用4版本2. 使用copy-webpack-plugin 拷贝静态资源采用5版本3. 使用optimize-css-assets-webpack-plugin  压缩css采用5版本4. 使用uglifyjs-webpack-plugin 压缩js采用2版本</code></pre><h3 id="3-1、开发环境配置"><a href="#3-1、开发环境配置" class="headerlink" title="3.1、开发环境配置"></a>3.1、开发环境配置</h3><pre><code class="js">// 主要实现热更新，不用压缩代码，完整的sourceMapconst Path = require(&#39;path&#39;)const Webpack = require(&#39;webpack&#39;)const WebpackConfig = require(&#39;./webpack.config&#39;)const WebpackMerge = require(&#39;webpack-merge&#39;)module.exports = WebpackMerge(WebpackConfig, &#123;  mode: &#39;development&#39;,  devtool: &#39;cheap-module-eval-source-map&#39;,  devServer: &#123;    port: 3000,    hot: true,    static: &#123;      directory: Path.join(__dirname, &#39;dist&#39;)    &#125;  &#125;,  plugins: [    new Webpack.HashedModuleIdsPlugin()  ]&#125;)</code></pre><h3 id="3-2、生产环境配置"><a href="#3-2、生产环境配置" class="headerlink" title="3.2、生产环境配置"></a>3.2、生产环境配置</h3><pre><code class="js">//实现css,js代码压缩const Path = require(&#39;path&#39;)const WebpackConfig = require(&#39;./webpack.config&#39;)const WebpackMerge = require(&#39;webpack-merge&#39;)const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;)const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)module.exports = WebpackMerge(  WebpackConfig,  &#123;    mode: &#39;production&#39;,    devtool: &#39;cheap-module-source-map&#39;,    plugins: [      new CopyWebpackPlugin([        &#123;          from: Path.resolve(            __dirname,            &#39;../public&#39;          ),          to: Path.resolve(            __dirname,            &#39;../dist&#39;          ),        &#125;,      ]),    ],    optimization: &#123;      minimizer: [        new UglifyJsPlugin(&#123;          cache: true,          parallel: true,          sourceMap: true,        &#125;),        new OptimizeCssAssetsWebpackPlugin(          &#123;&#125;        ),      ],      splitChunks: &#123;        chunks: &#39;all&#39;,        cacheGroups: &#123;          libs: &#123;            name: &#39;chunk-libs&#39;,            test: /[\\/]node_modules[\\/]/,            priority: 10,            chunks: &#39;initial&#39;, //只打包初始时依赖的第三方库          &#125;,        &#125;,      &#125;,    &#125;,  &#125;)</code></pre><h3 id="3-3、package-json"><a href="#3-3、package-json" class="headerlink" title="3.3、package.json"></a>3.3、package.json</h3><pre><code class="js">&#123;  &quot;name&quot;: &quot;webpack_4&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server --config build/webpack.config.js --open&quot;,    &quot;build:prod&quot;: &quot;webpack --config build/webpack.prod.js&quot;,    &quot;build:dev&quot;: &quot;webpack --config build/webpack.dev.js&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.18.2&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.18.2&quot;,    &quot;@webpack-cli/serve&quot;: &quot;^1.6.1&quot;,    &quot;autoprefixer&quot;: &quot;^8.6.5&quot;,    &quot;babel-loader&quot;: &quot;^8.2.5&quot;,    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;copy-webpack-plugin&quot;: &quot;^5.1.2&quot;,    &quot;css-loader&quot;: &quot;^3.6.0&quot;,    &quot;file-loader&quot;: &quot;^4.3.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^4.5.2&quot;,    &quot;less&quot;: &quot;^4.1.2&quot;,    &quot;less-loader&quot;: &quot;^5.0.0&quot;,    &quot;mini-css-extract-plugin&quot;: &quot;^0.9.0&quot;,    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.8&quot;,    &quot;postcss-loader&quot;: &quot;^4.3.0&quot;,    &quot;style-loader&quot;: &quot;^2.0.0&quot;,    &quot;uglifyjs-webpack-plugin&quot;: &quot;^2.2.0&quot;,    &quot;url-loader&quot;: &quot;^4.1.1&quot;,    &quot;vue&quot;: &quot;^2.6.14&quot;,    &quot;vue-loader&quot;: &quot;^15.7.0&quot;,    &quot;vue-style-loader&quot;: &quot;^4.1.3&quot;,    &quot;vue-template-compiler&quot;: &quot;^2.6.14&quot;,    &quot;webpack&quot;: &quot;^4.46.0&quot;,    &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;,    &quot;webpack-merge&quot;: &quot;^4.2.2&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@babel/polyfill&quot;: &quot;^7.12.1&quot;,    &quot;@vue/compiler-sfc&quot;: &quot;^3.2.36&quot;  &#125;&#125;</code></pre><h3 id="3-4、优化配置-TODO"><a href="#3-4、优化配置-TODO" class="headerlink" title="3.4、优化配置 TODO"></a>3.4、优化配置 TODO</h3><h2 id="4、配置路由-vue-router"><a href="#4、配置路由-vue-router" class="headerlink" title="4、配置路由 vue-router"></a>4、配置路由 vue-router</h2><ul><li><code>npm i -D vue-router@3</code></li></ul><h3 id="4-1、src下新增router文件夹，配置路由文件"><a href="#4-1、src下新增router文件夹，配置路由文件" class="headerlink" title="4.1、src下新增router文件夹，配置路由文件"></a>4.1、src下新增router文件夹，配置路由文件</h3><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;import Home from &#39;@/components/Home.vue&#39;import Hello from &#39;@/components/Hello.vue&#39;Vue.use(VueRouter)const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      component: Home    &#125;,    &#123;      path: &#39;/hello&#39;,      component: Hello    &#125;  ]&#125;)export default router</code></pre><h3 id="4-2、main-js引入router-components文件夹下新增两个组件，在根组件引用"><a href="#4-2、main-js引入router-components文件夹下新增两个组件，在根组件引用" class="headerlink" title="4.2、main.js引入router, components文件夹下新增两个组件，在根组件引用"></a>4.2、main.js引入router, components文件夹下新增两个组件，在根组件引用</h3><pre><code class="js">&lt;template&gt;&lt;div&gt;  &lt;div class=&quot;container&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;  &lt;div&gt;    &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;    &lt;router-link to=&quot;/hello&quot;&gt;nihao&lt;/router-link&gt;  &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Hello from &#39;./components/Hello&#39;import Home from &#39;./components/Home&#39;  export default &#123;    name: &#39;App&#39;,    data() &#123;      return &#123;        msg: &#39;测试配置dsad&#39;      &#125;    &#125;,    components: &#123;      Hello, Home    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .container &#123;    background-color: red;  &#125;&lt;/style&gt;</code></pre><h3 id="4-3、最终package-json"><a href="#4-3、最终package-json" class="headerlink" title="4.3、最终package.json"></a>4.3、最终package.json</h3><pre><code class="js">&#123;  &quot;name&quot;: &quot;webpack_4&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server --config build/webpack.config.js --open&quot;,    &quot;build:prod&quot;: &quot;webpack --config build/webpack.prod.js&quot;,    &quot;build:dev&quot;: &quot;webpack --config build/webpack.dev.js&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.18.2&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.18.2&quot;,    &quot;@webpack-cli/serve&quot;: &quot;^1.6.1&quot;,    &quot;autoprefixer&quot;: &quot;^8.6.5&quot;,    &quot;babel-loader&quot;: &quot;^8.2.5&quot;,    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;copy-webpack-plugin&quot;: &quot;^5.1.2&quot;,    &quot;css-loader&quot;: &quot;^3.6.0&quot;,    &quot;file-loader&quot;: &quot;^4.3.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^4.5.2&quot;,    &quot;less&quot;: &quot;^4.1.2&quot;,    &quot;less-loader&quot;: &quot;^5.0.0&quot;,    &quot;mini-css-extract-plugin&quot;: &quot;^0.9.0&quot;,    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.8&quot;,    &quot;postcss-loader&quot;: &quot;^4.3.0&quot;,    &quot;style-loader&quot;: &quot;^2.0.0&quot;,    &quot;uglifyjs-webpack-plugin&quot;: &quot;^2.2.0&quot;,    &quot;url-loader&quot;: &quot;^4.1.1&quot;,    &quot;vue&quot;: &quot;^2.6.14&quot;,    &quot;vue-loader&quot;: &quot;^15.7.0&quot;,    &quot;vue-style-loader&quot;: &quot;^4.1.3&quot;,    &quot;vue-template-compiler&quot;: &quot;^2.6.14&quot;,    &quot;webpack&quot;: &quot;^4.46.0&quot;,    &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^4.9.0&quot;,    &quot;webpack-merge&quot;: &quot;^4.2.2&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@babel/polyfill&quot;: &quot;^7.12.1&quot;,    &quot;@vue/compiler-sfc&quot;: &quot;^3.2.36&quot;,    &quot;vue-router&quot;: &quot;^3.5.2&quot;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vuecli </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuecli </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo简介</title>
      <link href="/2022/060816107.html"/>
      <url>/2022/060816107.html</url>
      
        <content type="html"><![CDATA[<p>官网： <a href="https://hexo.io/">Hexo</a><br>官方文档： <a href="https://hexo.io/docs/">documentation</a><br>社区： <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a><br>反馈： <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="同步至远程仓库"><a href="#同步至远程仓库" class="headerlink" title="同步至远程仓库"></a>同步至远程仓库</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo初识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
